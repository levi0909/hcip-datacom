# 02_OSPF详解

### 1.OSPF基础概念

`OSPF (Open Shortest Path First)`开放式最短路径优先协议是`IETF`组织开发的一个基于**链路状态的内部网关协议（IGP）**。目前`OSPF`主要有两个版本：`OSPF Version2`针对`IPv4`、`OSPF Version3`针对`IPv6`。

------

#### 1.1.链路状态协议

链路状态协议的核心思想是：**每个路由器维护整个网络的拓扑数据库（LSDB），通过计算最短路径树（SPT）来决定最佳路由**。

当我们构建了一个`OSPF`网络后，网络设备两两之间会建立`OSPF`邻居关系。邻居关系建立完成后，网络设备会将自己的**路由表**同步给邻居，路由信息就会像流感一样传播到整个`OSPF`域中。

但是，一个网络设备可能从多个邻居获取到相同网段的路由信息。根据路由表的规则（最优路由原则）会对相同网段的路由信息进行比较，只有最**优选**的才会放进路由表。这个比较的方式就是通过`SPF (Dijkstra)`算法计算得出的。

简单讲讲怎么计算出来的，每个路由器都会拥有**完整的链路状态数据库（LSDB）**，包含网络中所有路由器和链路的详细信息（如链路开销、邻居关系等）。路由器以**自身为起点（Root树根）**，逐步计算到其他所有节点的最短路径。最终生成一颗**最短路径树（SPT）**，用于构建路由表。而实际路径选择的依据是**链路开销（Cost）**，开销越小优先级越高。

所以，与距离数量路由协议相比，距离向量协议（如RIP）仅知道“下一跳”和“跳数”，而SPF算法基于全网拓扑计算最优路径。

![image-20250805194026891](https://gitee.com/chouhama/pic/raw/master/20250805194026971.png)

------

#### 1.2.区域与Router-ID

##### 1.2.1.OSPF区域（Area）

相同区域内的`OSPF`路由器拥有完全一致的`LSDB`，在区域内部，`OSPF`采用`SPF`算法完成路由计算。随着网络规模的扩大，路由器为了完成路由计算所消耗的内存、`CPU`等资源也越来越多，通过区域划分可以在一定程度上缓解路由器的压力。

**区域的作用**

- **减少泛洪范围：**限制`LSA`（链路状态通告）的传播范围，降低网络开销。
- **提高扩展性：**通过分层设计（骨干区域 + 非骨干区域）支持大规模网络。
- **优化路由计算：**区域内使用`SPF`算法，区域间可通过`ABR`汇总路由，减少计算复杂度。

------

**区域的类型**

**注意：**==在`OSPF`中区域的概念存在于设备的接口，也就是说一台设备的不同接口可以属于不同的`OSPF`区域。==

1. **骨干区域（Area 0）**
   - **核心作用：**所有非骨干区域必须直接连接到`Area 0`，或者使用虚链路（`Virtual Link`）
   - **特点：**
     - 负责在不同区域间传递路由信息，例如把区域1的路由传递给区域2。
     - 只有`ABR`能在`Area 0`和其他区域间转发路由。
2. **非骨干区域**

![image-20250805223327076](https://gitee.com/chouhama/pic/raw/master/20250805223327161.png)

3. **特殊区域**

------

**区域设计原则**

- **所有非骨干区域必须与Area 0直连**
- **避免区域过大：**单个区域内的路由器建议不超过50台
- **合理使用Stub/NSSA：**减少路由表大小，提升性能

------

**设备角色**

区域将`OSPF`设备划分成多个部分，从而诞生出两种`OSPF`设备角色：

1. **ABR（Area Border Router）**

   - 连接多个区域（至少一个接口在`Area 0`）。就是在`OSPF`进程中，多个`OSPF`区域宣告了网段，且正常建立了邻居关系。

   - ```
     ospf 1
     	area 0
     		network 192.168.1.0 0.0.0.255
     		network 192.168.2.0 0.0.0.255
     	area 1
     		network 192.168.3.0 0.0.0.255
     		network 192.168.4.0 0.0.0.255
     ```

   ![image-20250805223522982](https://gitee.com/chouhama/pic/raw/master/20250805223523049.png)

2. **ASBR（Autonomous System Boundary Router）**
   - 将外部路由（如`IS-IS`、静态路由、其他`OSPF`进程）重分发到`OSPF`。也就是`OSPF`域与其他路由协议的边界。

![image-20250805223703408](https://gitee.com/chouhama/pic/raw/master/20250805223703482.png)

------

##### 1.2.2.Router-ID

**Router-ID的作用：**

- **唯一表示`OSPF`设备：**类似但不是`IP`地址，用于邻居建立和`LSA`标识。
- **选举DR/BDR：**在广播网络中，`Router-ID`大的路由器优先称为`DR`。

------

**Router-ID的确定规则：**

1. **手动指定（推荐）**

   ```
   ospf 1 router-id 1.1.1.1
   ```

2. **自动选择**
   1. 选择当前设备上**已配置的`Loopback`接口中最大的`IP`地址。**
   2. 若没有配置`LoopBack`，选择**物理接口中最大的地址**。

------

**Router-ID的注意事项**

- 修改`Router-ID`必须重启`OSPF`进程才能生效：

  ```
  reset ospf process
  ```

- 处于方便的角度考虑，一般指定的`Router-ID`都需要方便辨识。比如：`1.0.0.1、2.0.0.2`等，这样做的好处是在某一台设备上查看`OSPF LSDB`或邻居表，都会非常便利的知道对方的设备名。

------

**提问环节1：**

我在配置`OSPF`时没有指定`Router-ID`，当前设备上有如下几个`IP`地址，`OSPF`会选择哪一个作为`Router-ID`：

| **接口名称** |    **IP地址**     | **子网掩码** | 接口状态 |
| :----------: | :---------------: | :----------: | :------: |
| `loopback0`  |     `1.1.1.1`     |    `/32`     |    up    |
| `loopback1`  |     `2.2.2.2`     |    `/32`     |    up    |
| `loopback10` | `100.100.100.100` |    `/32`     |    up    |
| `loopback20` |    `224.0.0.1`    |    `/32`     |    up    |
|   `G0/0/0`   |     `3.3.3.3`     |    `/32`     |    up    |

------

**提问环节2：**

我在配置`OSPF`时没有指定`Router-ID`，当前设备上有如下几个`IP`地址，`OSPF`会选择哪一个作为`Router-ID`：

| **接口名称** |    **IP地址**     | **子网掩码** | 接口状态 |
| :----------: | :---------------: | :----------: | :------: |
|    G0/0/0    |     `1.1.1.1`     |    `/32`     |    up    |
|    G0/0/1    |     `2.2.2.2`     |    `/32`     |    up    |
|    G0/0/2    | `100.100.100.100` |    `/32`     |   down   |

------

**提问环节3：**

我在配置`OSPF`时没有指定`Router-ID`，当前设备上有如下几个`IP`地址，`OSPF`会选择哪一个作为`Router-ID`：

| **接口名称** |    **IP地址**     | **子网掩码** | 接口状态 |
| :----------: | :---------------: | :----------: | :------: |
|    G0/0/0    |     `1.1.1.1`     |    `/32`     |   down   |
|    G0/0/1    |     `2.2.2.2`     |    `/32`     |   down   |
|    G0/0/2    | `100.100.100.100` |    `/32`     |   down   |

------

#### 1.3.报文类型

`OSPF`的报文总共有五种类型，它们的目的是为了发现邻居、建立邻居、维护邻居、交互`LSA`（链路状态通告）。

![image-20250812041646524](https://gitee.com/chouhama/pic/raw/master/20250812041653802.png)

|            **报文类型**             |                         **报文作用**                         |
| :---------------------------------: | :----------------------------------------------------------: |
|            **Hello报文**            |           周期性发送，用来发现和维持OSPF邻居关系。           |
| **DD报文** （Database Description） | 描述本地LSDB（链路状态数据库）的摘要信息，用于两台设备进行数据库同步。 |
| **LSR报文** （Link State Request）  | 向对方请求所需的LSA。设备必须在成功交换DD报文后才会发送LSR报文。 |
|  **LSU报文** （Link State Update）  |          向对方发送其所需要的LSA（链路状态通告）。           |
|  **LSAck报文** （Link State Ack）   |            对收到的LSA进行确认，确保可靠性传输。             |

> [!NOTE]
>
> LSA指的是携带路由器接口、邻居、链路开销等信息的数据。用于构建链路状态数据库。

------

#### 1.4.网络类型

`OSPF`根据链路层协议类型，将网络分为如下四种类型：

|                **网络类型**                 |                    **含义及报文传输方式**                    |
| :-----------------------------------------: | :----------------------------------------------------------: |
|          **广播类型（Broadcast）**          | 当链路层协议是 Ethernet、FDDI 时，默认网络类型为 Broadcast。在该网络中： • 以组播形式发送 Hello、LSU、LSAck 报文（组播地址 `224.0.0.5` 和 `224.0.0.6`）。 • 需要选举 DR/BDR 以减少泛洪。 |
| **NBMA类型** （Non-Broadcast Multi-Access） | 当链路层协议是帧中继、X.25 时，默认网络类型为 NBMA。在该网络中： • **以单播形式发送所有协议报文**（Hello、DD、LSR、LSU、LSAck）。 • 必须手动配置邻居，且需选举 DR/BDR（因无广播能力）。 |
|  **点到多点 P2MP** （Point-to-Multipoint）  | 无默认链路层协议属于此类型，通常由 NBMA 强制更改而来（适用于非全连通网络）。在该网络中： • 以组播形式发送 Hello 报文（`224.0.0.5`）。 • **以单播形式发送其他报文**（DD、LSR、LSU、LSAck）。 • **不选举 DR/BDR**。 |
|      **点到点 P2P** （Point-to-Point）      | 常见于 PPP、HDLC 链路。在该网络中： • 以组播形式发送 Hello 报文（`224.0.0.5`）。 • 以单播形式发送其他报文（DD、LSR、LSU、LSAck）。 • **不选举 DR/BDR**（仅两个节点直接通信）。 |

需要注意的是，不同的网络类型中发送数据包的方式（单播、组播）、建立邻居（邻接）的方式会有所不同。

------

#### 1.5.邻居状态机

在`OSPF`网络中，为了交换路由信息，`OSPF`设备之间首先要建立**邻接**关系，邻居（`Neighbors`）和邻接（`Adjacencies`）关系是两个不同的概念。

- **邻居关系：**`OSPF`设备启动后，会通过`OSPF`接口向外发送`Hello`报文，收到`Hello`报文的`OSPF`设备会检查报文中所定义的参数，如果双方一致就会形成邻居关系，两端设备互为邻居。
- **邻接关系：**形成邻居关系后，如果两端设备成功交换`DD`报文和`LSA`，才建立邻接关系。

可以理解为邻居是设备与设备之间互相信任的过程，邻居关系建立完成后，才可以互相交互`LSA`。当所有的`LSA`同步完成后（`LSDB`同步），进入邻接关系。邻接关系建立完成后，这才是`OSPF`设备之间的最终状态。

`OSPF`总共有八种状态机：`Down、Attempt、init、2-way、Exstart、Exchange、Loading、Full`。

- **Down：**邻居会话的初始阶段，表明设备尚未检测到邻居或主动终止了邻居。
- **Attempt：**该状态仅发生在`NBMA`网络中，表明对端在邻居失效时间间隔超时前仍然没有回复`Hello`报文。此时路由器依然按照`Hello interval`轮询向对端发送`Hello`报文。
- **Init：**收到`Hello`报文后状态为`Init`。
- **2-way：**收到的`Hello`报文中包含有自己的`Router-ID`，则状态切换为`2-way`；如果不需要形成邻接关系则邻居状态机就停留在次状态，否则进入`Exstart`状态。
- **Exstart：**开始协商主从关系，并确定`DD`的序列号，此时状态为`Exstart`。
- **Exchange：**主从关系协商完毕后开始交换`DD`报文，此时状态为`Exchanage`。
- **Loading：**`DD`报文交换完成即`Exchange done`，此时状态为`Loading`。
- **Full：**`LSR`重传列表为空，此时状态为`Full`。

------

#### 1.6.邻居发现

`OSPF`通过`Hello`报文发现和维持邻居关系。邻居关系不同于邻接关系，只有达到`2-way`状态的路由器才算邻居关系（双向邻居关系）建立起来。`OSPF`在当前设备所有启用`OSPF`协议的接口发送`Hello`报文，不同的网络上，`OSPF`发送`Hello`报文的间隔和目的地址不同：

- 在广播和`p2p`网络中，`Hello`每`10s`发送一次，在`NBMA`和`p2mp`网络中每`30s`发送一次。
- 在广播、`p2p`和`p2mp`的网络中，`OSPF`通过组播的`Hello`报文自动发现邻居，组播地址为：`224.0.0.5`（所有`OSPF`路由器）。在`NBMA`网络中，需要手工指定邻居。

------

在建立邻居关系时，路由器必须对`Hello`报文中携带的参数达成一致，对收到的`Hello`报文中的参数进行检查比对，以下是比对内容：

- **Hello/Dead interval：**时间一致才能建立邻居关系。`Dead interval`是`Hello interval`的四倍。
- **区域ID：**相邻的路由器在同一区域才能建立邻居关系，检查`OSPF`头中的`Area ID`，`Area ID`出现在所有`OSPF`报文的头部而非`Hello`报文中。
- **区域类型：**区域类型要一致。判断区域类型是否一致要参考`Hello`报文中的`Option`位，其中`E`和`N/P`置位代表的含义不同，不同的`Option`置位决定了不同的区域类型。

- **认证类型和密钥一致：**只有验证通过才能建立邻居关系。
- **Router ID无冲突：**直连路由器要建立邻居关系时，彼此间`Router ID`一定要不一样。

![image-20250806223348248](https://gitee.com/chouhama/pic/raw/master/20250806223355392.png)

------

#### 1.7.邻居关系建立过程

![image-20250806225637467](https://gitee.com/chouhama/pic/raw/master/20250806225637566.png)

`OSPF`邻居的建立过程：

- 三次握手
- `Down、Init、2-way`
  - **init:**单向邻居建立成功
  - **2-way:**双向邻居建立成功

![image-20250806225430660](https://gitee.com/chouhama/pic/raw/master/20250806225430759.png)

1. 设备`A`向`224.0.0.5`发送`Hello`报文（此时两台设备都处于`Down`状态）
2. 设备`B`收到设备`A`发送的`Hello`报文，但因为`Hello`报文中的`Active Neighbor`字段没有包含当前路由器的`Router ID`（此时`B`查看`Peer`状态为`Init`）
3. 设备`B`向`224.0.0.5`发送`Hello`报文，该报文中的`Active Neighbor`字段为设备`A`的`Router-ID`
4. 设备`A`收到设备`B`发送的`Active Neighbor`字段为自己的`Router-ID`的`Hello`报文（此时设备`A`查看`Peer`状态为`2-way`）
5. 设备`A`向`224.0.0.5`发送`Hello`报文，该报文中的`Active Neighbor`字段为设备`B`的`Router-ID`
6. 设备`B`收到设备`A`发送的`Active Neighbor`字段为自己的`Router-ID`的`Hello`报文（此时设备`B`查看`Peer`状态为`2-way`）

------

#### 1.8.邻接关系建立过程

**注意：**在**广播和`NBMA`**类型的网络中，邻接关系的建立发生在`DR`和`BDR`选举之后。在其他网络类型中没有`DR/BDR`选举，邻居关系建立完成后便开始建立邻接关系。

**邻接关系建立过程如下图：**

![image-20250806230125539](https://gitee.com/chouhama/pic/raw/master/20250806230125637.png)

------

##### 1.8.1.DR与BDR选举

![img](https://gitee.com/chouhama/pic/raw/master/20250810213000821.png)

在`OSPF`的 **广播网络（Broadcast）** 和 **非广播多路访问（NBMA）** 网络中，为了避免全互联的邻接关系（`n(n-1)/2` 个邻接），OSPF 引入了 **DR（Designated Router，指定路由器）** 和 **BDR（Backup Designated Router，备份指定路由器）** 的概念。它们的作用是 **减少 LSA 泛洪**，提高网络效率。

在广播网络和`NBMA`中，一个广播域里可能会有`2`个以上的`OSPF`设备进行邻居关系的建立，如果没有`DR/BDR`就需要两两之间建立邻居关系，有了`DR/BDR`之后，就会减少这个广播域内的**邻接关系数量**。如下图：

![image-20250806230820067](https://gitee.com/chouhama/pic/raw/master/20250806230820153.png)

![选举DR前后对比图](https://gitee.com/chouhama/pic/raw/master/20250808214951886.png)

- 没有`DR/BDR`的邻接数量：6
- 有`DR/BDR`的邻接数量：5
  - 公式：`( n - 1 ) + ( n - 2)` 或 ` 2n - 3`

------

**角色与作用**

- **DR（指定路由器）：只有一个**
  - 负责与所有`DROthers`建立邻接关系。
  - 代表当前网络所有设备发送`LSA`，减少重复泛洪。
- **BDR（备份指定路由器）：只有一个**
  - 在`DR`失效时接管其职责。
  - 与`DR`一样，与所有`DROthers`建立邻接关系，但是不向其泛洪`LSA`。
- **`DROthers`（非`DR/BDR`路由器）：**
  - 仅与`DR\BDR`建立邻接关系，与`DROthers`保持`2-way`状态。

------

**选举规则**

`DR/BDR`的选举基于 **Router Priority（优先级）** 和 **Router ID**，具体规则如下：

|                **规则**                 |                           **说明**                           |
| :-------------------------------------: | :----------------------------------------------------------: |
|      **1. 比较优先级（Priority）**      | 优先级高的成为 DR，次高的成为 BDR（默认 **1**，范围 **0-255**）。 |
|  **2. 如果优先级相同，比较 Router ID**  | Router ID 大的胜出（手动配置的 Router ID 优先，否则取最高 IP 地址）。 |
|      **3. 优先级为 0 不参与选举**       | 如果接口优先级设为 `0`，则该路由器不会成为 DR/BDR（永远是 DROther）。 |
| **4. 选举是非抢占的（Non-Preemptive）** | 即使新加入的路由器优先级更高，也不会抢占现有 DR/BDR，除非 DR/BDR 故障。 |

有几个隐藏规则：

1. 在你配置`OSPF`的时候，如果较晚将优先级最大的设备宣告进`OSPF`就会导致它无法当上`DR/BDR`。

2. 如果某台设备已经是`DR/BDR`了，你修改它的优先级，也无法让它立刻成为`DR/BDR`

3. 解决上述两个问题的方式是：在当前局域网中所有的`OSPF`上执行`reset ospf process`

4. 修改优先级的方式是：

   ```
   [Huawei] interface Gi0/0/0
   [Huawei-Gi0/0/0] ospf dr-priority [0-255]
   ```

------

**选举流程**

实际上在广播和`NBMA`网络中，`DR/BDR`的选举是与邻居关系的建立同步完成的，也就是说一旦有一对`OSPF`设备进入`2-way`状态，`DR/BDR`就已经选举完成了。因为，`Hello`报文中携带了`Router-ID、Router Priority`以及`DR/BDR`信息。

所以，你如果指定某一个`OSPF`的设备是当前网络中的`DR`，你应该最先在这台设备上宣告网段，以便让它成为`DR`。

另外，因为`DR/BDR`选举完成后，`OSPF`再向外通告`Hello`报文时，会携带`DR/BDR`的地址，所以后续加入进来的`OSPF`设备都会跳过`DR/BDR`选举过程。

------

**监听地址**

在广播和`NBMA`网络中，`DR/BDR`会监听组播地址`224.0.0.6`，`DROthers`通过`224.0.0.6`发送`LSU`和`LSR`报文，向`DR/BDR`索取和泛洪`LSA`。

这样做的好处是避免`DROthers`之间直接交换`LSA`，减少网络流量。

------

**伪节点**

在多路访问网络中，OSPF 将 DR 抽象为一个 **伪节点**，其核心作用：

1. 简化拓扑计算：
   - 在 SPF（最短路径优先）计算中，伪节点代表整个多路访问网络，其他路由器只需计算到伪节点的路径，而非所有邻居。
2. 减少 LSA 数量：
   - DR 生成 **Network-LSA（Type-2 LSA）**，描述该多路访问网络中的所有路由器（包括伪节点），避免每个路由器单独通告链路信息。

![image-20250810212223279](https://gitee.com/chouhama/pic/raw/master/20250810212230534.png)

------

##### 1.8.2.邻接关系建立过程

邻接关系是邻居路由器间为完成`LSDB`同步而发生的`LSA`交互过程，也是邻居路由器间初次通告`LSA`、快速同步的过程。它是`LSA`泛洪的一种方式，同步完成之后，邻居路由器间最终状态为`FULL`。

**邻接关系状态迁移过程如下：**

###### 1.ExStart

![image-20250809005828313](https://gitee.com/chouhama/pic/raw/master/20250809005828431.png)

在`ExStart`状态下，本地路由器和邻居路由器间互传空`DD`报文。作用如下：

- 确定主/从关系：避免`DD`报文序列号冲突，保证可靠传输。
  - 选举规则：比较双方的`Router-ID`，值更大的一方称为`Master`。
    - `Master`：负责控制`DD`报文的序列号分配。
    - `Slave`：响应`Master`的序列号，确保同步有序
- 确定`DD`的初始序列号
- 比较接口`MTU`（可选） 

------

在`ExStart`状态下，路由器互相发送的空`DD`报文中置`I(Initialize)`，`M(More)`及`MS(Master/Slave)`位。

- **I位：**初始化位，仅头两份`DD`报文中置该位，代表同步过程开始。
- **M位：**如果`M`位为0，则代表后续`DD`报文中没有`LSDB`摘要要传。任何一方`M`位不为`0`，`Master`就要继续发送`DD`报文，`Slave`收到之后，不论是否还有`LSDB`摘要要传递，一定要回应`DD`报文。
- **M/S位：**初始双方均认定自己是`Master`，所以`M/S`均置位。双方收到对方的`DD`，`Router ID`高的一方为`Master`，其后续`DD`报文中，`M/S`会一直置位。`Master`会一直发送`DD`报文，`Slave`回应的`DD`报文是对`Master`发送的`DD`报文的确认。此过程持续到双方的`LSA`头都交换完成。

------

###### 2.Exchange

![image-20250808210840471](https://gitee.com/chouhama/pic/raw/master/20250808210847692.png)

在`Exchange`状态下，根据`ExStart`状态确定的主从关系，路由器之间交换`LSDB`摘要（`LSDB`摘要是`OSPF`链路状态数据库的摘要信息，用来与本端设备上的`LSDB`进行对比，查询自己缺少哪些`LSA`）。

选举出`Master`后，`Slave`路由器向`Master`回送`DD`报文，其中包含`LSDB`的摘要，并使用`Master`的序列号。`Master`也把自己的`LSDB`摘要用`DD`报文发送给`Slave`，序列号加一，同时，`Slave`收到后，会回应相同序列号的`DD`报文。

任何一侧只要还有未传递完的`LSA`头，`Master`就一定要产生`DD`报文并由`Slave`回应。`Exchange`阶段通过这种可靠的`DD`交互，完成快速交换`LSA`头。

> [!NOTE]
>
> Master和Slave的角色分工不同，Master是由Router-ID高的路由器充当，负责发送序列号递增的DD报文，如果Master没能得到Slave的回应，则Master每隔5秒重传该DD报文，直至收到Slave的DD报文。

`Exchange`交互`DD`报文的过程是可靠的。`Master`发送`seq=y+n`的报文，`Slave`回应`seq=y+n`的报文，`Master`和`Slave`的`DD`报文中`M`都不置位，`Exchange`过程才结束。

------

###### 3.Loading

![](https://gitee.com/chouhama/pic/raw/master/20250809010835131.png)

**步骤：**

1. 本端路由器根据`DD`报文交互的`LSDB`摘要发现当前缺失某条`LSA`。
2. 本端路由器向邻居发送`LSR`，用来请求缺失的`LSA`。
3. 对端路由器收到`LSR`后，发送包含被请求的`LSA`的`LSU`报文。
4. 本段路由器收到对端发送的`LSU`报文后，确认无误便向对端发送`LSACK`。
5. 若两端的`LSDB`同步完成，则进入`FULL`状态。

------

###### 4.Full

在`Full`状态下，邻居路由器之间已完成同步过程，建立起完全邻接关系。

------

##### 1.8.3.广播网络类型中报文目的地址

|             **报文类型**              |       **目标 IP 地址**       |        **目标 MAC 地址**        |          **发送范围**          |                     **用途**                     |
| :-----------------------------------: | :--------------------------: | :-----------------------------: | :----------------------------: | :----------------------------------------------: |
|               **Hello**               | `224.0.0.5`（AllSPFRouters） |       `01-00-5E-00-00-05`       |        所有 OSPF 路由器        |     发现邻居、维护邻接关系（DR/BDR 选举）。      |
|     **DD (Database Description)**     |    **单播**（邻接路由器）    |          对方 MAC 地址          | 仅邻接路由器（DR/BDR ↔ 非 DR） |  交换 LSDB 摘要信息（ExStart/Exchange 状态）。   |
|     **LSR (Link State Request)**      |    **单播**（邻接路由器）    |          对方 MAC 地址          |          仅邻接路由器          |         请求完整的 LSA（Loading 状态）。         |
|      **LSU (Link State Update)**      |   `224.0.0.5` 或 **单播**    | `01-00-5E-00-00-05` 或 对方 MAC |      所有路由器或特定邻居      | 发送更新的 LSA（泛洪时用组播，重传时可能单播）。 |
| **LSAck (Link State Acknowledgment)** |   **单播** 或 `224.0.0.5`    | 对方 MAC 或 `01-00-5E-00-00-05` |     邻接路由器或所有路由器     | 确认收到的 LSA（通常单播，但可能组播泛洪确认）。 |

1. **Hello 报文**
   - **始终组播**（`224.0.0.5`），确保所有 OSPF 路由器都能收到，用于邻居发现和保活。
   - 在广播网络中，非 DR/BDR 的路由器只与 DR/BDR 建立邻接关系。
2. **DD/LSR/LSAck 报文**
   - **初始阶段**（ExStart/Exchange）：DD 报文通过单播交换（DR/BDR 与非 DR 之间）。
   - **Loading 状态**：LSR 和 LSU 通常单播（直接请求和响应）。
   - **LSAck**：多数实现使用单播确认，但标准允许组播（`224.0.0.5`）泛洪确认。
3. **LSU 报文**
   - **首次泛洪**：使用组播 `224.0.0.5`（所有 OSPF 路由器）。
   - **重传或点对点响应**：可能改用单播（如对方未确认）。

------

##### 1.8.3.用实验验证理论

```
LSW1
int vlan 1
  ip add 12.1.1.1 24
  quit
int loo0
  ip add 1.1.1.1 32
  quit
ospf 1 router-id 1.1.1.1
  area 0
    network 12.1.1.1 0.0.0.0
    network 1.1.1.1 0.0.0.0
    quit

LSW2
int vlan 1
  ip add 12.1.1.2 24
  quit
int loo0
  ip add 2.2.2.2 32
  quit
ospf 1 router-id 2.2.2.2
  area 0
    network 12.1.1.2 0.0.0.0
    network 2.2.2.2 0.0.0.0
    quit
```

**结论：**

在抓包的过程中，可以发现基本现象与理论中一致。但是有一个地方较为特殊：

![image-20250809015845663](https://gitee.com/chouhama/pic/raw/master/20250809015845805.png)

这两个`LSU`报文的目的地址都为`224.0.0.5`，说明是一个向所有`OSPF`泛洪的更新。点开具体的报文，会发现该`LSU`中包含了当前设备所有的`LSA`，所以这是一次增量更新：

![image-20250809015957787](https://gitee.com/chouhama/pic/raw/master/20250809015957936.png)

这么做的原因是为了加快`LSDB`同步的速度。但是，实际上通过抓包我们可以发现，后续还是和理论学习中一样，使用单播发送了`LSR`和`LSU`，为什么要这么设计呢？是不是多次一举呢？

OSPF采用 **"泛洪+点对点确认"** 的双重保障机制，这是协议可靠性的核心设计：

1. **第一层：组播泛洪（快速扩散）**
   - 通过`224.0.0.5`广播LSU（如包53/54），实现拓扑变化的快速传播
   - 特点：无确认、尽力而为的传输
2. **第二层：单播确认（可靠同步）**
   - 通过单播LSR/LSU/LSAck（如包55-61）确保关键路由器100%同步
   - 特点：有确认、按需重传

------

当`OSPF`拓扑稳定后，仅通过组播泛洪`224.0.0.5`发送增量`LSU`。是为了应对在网络拓扑发生变化或者出现故障等情况下，快速应对的方式。一对一同步`LSA`的方式效率过低，只适用于邻居建立之初。

------

###### 1.8.4.DR/BDR场景

`DROther`需要通过`224.0.0.6`发送`LSU`给`DR/BDR`，用来更新路由。随后，`DR`再通过`224.0.0.5`发送`LSU`给`DROther`。`DROthers`也需要通过`224.0.0.6`发送`LSACK`给`DR`。

![image-20250809013305494](https://gitee.com/chouhama/pic/raw/master/20250809013305616.png)

`DR:12.1.1.1`

`BDR:12.1.1.3`

------

#### 1.9.周期性泛洪与触发式泛洪

##### 1.9.1.触发式泛洪

1. **触发条件：**当以下事件发生时，OSPF 会立即泛洪更新的 LSA：

   - 链路状态变化（如接口 UP/DOWN）

   - 新路由器加入网络

   - 现有 LSA 的序列号更新（如手动重置 OSPF 进程）

   - 收到邻居的 LSR（链路状态请求）需要回复

2. **核心特点**

   - **立即响应**：毫秒级触发，无需等待定时器

   - **增量更新**：仅发送变化的 LSA（非全量）

   - **目标明确**：通过 `224.0.0.5`（AllSPFRouters）或 `224.0.0.6`（AllDRouters）组播

------

##### 1.9.2.周期性泛洪

1. **触发条件：**
   - **默认每 30 分钟**（LSA 的 `RefreshTime`，RFC 2328 规定）
   - 与网络状态变化无关，是预防性维护机制
2. **核心特点：**
   - **全量刷新**：重新通告所有本地生成的 LSA
   - **防老化机制**：重置 LSA 的 `Age` 计时器（避免达到 `MaxAge` 3600 秒被删除）
   - **携带特殊标志**：`DoNotAge=1`（RFC 5613 扩展）

------

#### 1.10.MTU不一致

`OSPF`在交换`DD`报文时会检查彼此的接口`MTU`，`MTU`决定了发送的`OSPF`报文大小，同时也决定了可接收的`OSPF`报文大小。如果通信双方的`MTU`不一致，会导致双方的邻居状态停留在`ExStart`或`Exchange`。

在 `ExStart` 阶段，路由器会发送 **空内容的 DBD 报文**（仅包含头部，`I=1, M=1, MS=1`），并在报文中携带 **Interface MTU 值**（取自接口配置的 MTU）。

- 如果对端接口的 MTU **小于** DBD 报文中声明的 MTU，对端会 **静默丢弃该 DBD 报文**（无任何错误提示）。
- 丢弃后，发送方因未收到确认，会 **持续重传 DBD 报文**，而接收方因未收到合法 DBD 报文，**无法进入 `Exchange`**。

**现象：**

- `MTU`较大的一端其邻居状态会卡在`Exchange`
- `MTU`较小的一端其邻居状态会卡在`ExStart`

**这是因为，`OSPF`对于`MTU`的要求是，对端小于等于本接口`MTU`。**

华为设备默认情况下，邻接关系处在`ExStart/Exchange`状态时，缺省情况下`DD`报文中`Interface MTU`为`0`，`OSPF`既不填充接口实际`MTU`值，也不执行`MTU`一致性检查。而通信双方接口配置的`MTU`不一致，`OSPF`在同步`LSDB`时可能因`MTU`不一致而无法进入`FULL`状态。

华为使用`ospf mtu-enable`命令可开启接口填充及检查`MTU`。

比较`MTU`的目的是为了避免一端的报文太大，另一侧无法接受。

------

#### 1.11.提问：p2p与广播是否可以建立邻居

`Broadcast`和`p2p`可以相互建立邻居关系，可以完成数据库同步，但无法计算出对方的路由。原因是`Broadcast`需要连接到虚节点，而`p2p`网络需要和邻居节点直连，在逻辑拓扑上，二者无法连接到义气，所以计算路由时，互相都无法算出各自节点后面的路由。

**没法计算路由的原因：发送的`LSA`类型不一致，工作方式不一致。**

------

### 2.进阶

#### 2.1.LSA概述及泛洪

`LSA(Link-State Advertisement)`链路状态通告，用于在`OSPF`网络中传递链路状态信息，每个路由器通过交换`LSA`构建统一的链路状态数据库（`LSDB`），并基于此计算最短路径树。`LSA`的作用如下：

- **描述网络拓扑**：LSA 携带路由器接口、邻居、链路成本、网络类型等信息。
- **同步 LSDB**：所有 OSPF 路由器通过泛洪（Flooding）LSA，确保区域内 LSDB 一致。
- **支持分层设计**：通过不同类型的 LSA 实现 OSPF 区域（Area）间的路由隔离与汇总。

------

`OSPF`定义了多种`LSA`类型，每种类型承载不同的拓扑信息：

| **LSA 类型** |     **名称**     |         **生成者**         | **作用范围** |                **关键功能**                |
| :----------: | :--------------: | :------------------------: | :----------: | :----------------------------------------: |
|  **Type 1**  |    Router-LSA    |      所有 OSPF 路由器      |    本区域    |        描述路由器的直连链路和邻居。        |
|  **Type 2**  |   Network-LSA    |      DR（指定路由器）      |    本区域    |  描述多路访问网络（如以太网）中的伪节点。  |
|  **Type 3**  |   Summary-LSA    |   ABR（区域边界路由器）    |    跨区域    | 汇总区域内的路由到其他区域（非明细路由）。 |
|  **Type 4**  | ASBR-Summary-LSA |            ABR             |    跨区域    |        告知其他区域如何到达 ASBR。         |
|  **Type 5**  | AS-External-LSA  | ASBR（自治系统边界路由器） | 整个 OSPF 域 |      通告外部路由（如重分布的路由）。      |
|  **Type 7**  |     NSSA-LSA     |   ASBR（仅在 NSSA 区域）   |  NSSA 区域   |  类似 Type 5，但仅在 NSSA 区域内部使用。   |

------

##### 2.1.1.LSA格式及类型

![image-20250810215653248](https://gitee.com/chouhama/pic/raw/master/20250810215653423.png)

- **LS Age**：LSA 的存活时间（秒），超过 `MaxAge`（3600 秒）会被丢弃。
  - 无论`LSA`是在链路上传递，还是保存在`LSDB`中，`LS age`值都会不停增长。默认，泛洪时每经过一台路由器其`Age`增加1。
- **Otions：**8比特（8个二进制数），告诉其他路由器自己支持的功能。
  - `O-bit`标记路由器是否支持 **Opaque LSA**（Type 9/10/11），这是一种扩展OSPF功能的机制，用于传递非标准路由信息（如流量工程、SDN控制信息等）。
    - **Type 9 LSA**：链路本地范围（Link-local）
    - **Type 10 LSA**：本地区域范围（Area-local）
    - **Type 11 LSA**：整个OSPF域范围（AS-wide）
  - `E-bit`用来标记是否允许传播`AS`外部路由
    - 若区域配置为Stub或NSSA，区域内所有路由器的Hello报文中`E=0`，禁止5类LSA。
    - `E=1`，允许传播AS外部路由。

![image-20250812163027838](https://gitee.com/chouhama/pic/raw/master/20250812163028076.png)

| **比特位** |           **名称**           |                         **功能说明**                         |
| :--------: | :--------------------------: | :----------------------------------------------------------: |
| **比特7**  |        **DN** (Down)         |      用于MPLS VPN场景，防止环路（通常由PE路由器设置）。      |
| **比特6**  |        **O** (Opaque)        |  支持Opaque LSA（RFC 2370），用于扩展功能（如TE流量工程）。  |
| **比特5**  |   **DC** (Demand Circuit)    | 支持按需电路（RFC 1793），适用于按需拨号链路（抑制周期性Hello）。 |
| **比特4**  | **EA** (External Attributes) | 支持外部属性LSA（RFC 8362），用于BGP-OSPF交互（较少使用）。  |
| **比特3**  |        **N/P** (NSSA)        | **N**比特：支持NSSA区域（RFC 3101）；**P**比特：允许7类LSA在NSSA内传播。 |
| **比特2**  |      **MC** (Multicast)      |  支持MOSPF（组播OSPF，RFC 1584，现已被PIM取代，极少使用）。  |
| **比特1**  |       **E** (External)       | **E=1**：允许AS外部LSA（5类/7类）；**E=0**：区域为Stub/NSSA（禁止5类LSA）。 |
| **比特0**  |         **MT** (MT)          |    支持多拓扑OSPF（RFC 4915），允许不同拓扑独立计算路径。    |

- **LS Type：**8bit代表不同`LSA`类型
- **Link-State ID**：32bit，唯一标识 LSA（如 Router ID、网络地址等）。
- **Advertising Router**：32bit，生成该 LSA 的Router ID。
- **LSSequence Number**：32bit，用于检测新旧 LSA（越大越新），其他路由器根据这个值判断哪个`LSA`最新。
- **Checksum**：校验数据完整性。

- **Length：**16bit，`LSA`的总长度，包括`LSA Header`以字节为单位。

------

##### 2.1.2.泛洪机制

**何为泛洪？**

`OSPF`的路由信息都是通过`LSDB`中的`LSA`计算出来的，所以`LSDB`的一致性及快速同步直接影响`OSPF`路由的收敛性能。

**泛洪的范围**

一个区域内所有`OSPF`路由器要有一个相同的`LSDB`，这些`LSA`在区域内泛洪给每台路由器，泛洪的过程是路由器把自己产生或学习的`LSA`向所有其他邻居通告的过程。

`LSDB`内任何`LSA`的变化都会触发当前路由器通告该变化给邻居并泛洪至所属区域，为了确保`LSDB`被及时更新且保证其内容的一致性，`OSPF`泛洪使用`LSU`和`LSAck`来保证泛洪的可靠性。

每台路由器在一个接口收到泛洪的`LSA`报文，会继续向其他接口泛洪。例如，在`MA`网段上，若`DRother`向`DR/BDR`泛洪，则`DR`会以组播方式将`LSU`(包含`LSA`)向其他`DRother`泛洪。

**确认机制**

泛洪过程是一个可靠过程，有确认机制。其中每份泛洪的`LSA`都必须被确认。包含显示确认或隐式确认。例如，接收者收到一份`LSU`的泛洪，恰巧它也需要发送`LSU`给发送方，可在`LSU`中包含需要被确认的`LSA`头来完成确认，这样可以减少单独发送`LSACK`的过程。

**LSA重传**

当一份`LSA`被泛洪出去，当前路由器会记录该接口的所有邻居数量并维护重传列表，没有收到显示或隐式确认的`LSA`，路由器会在`5s`后单播重传更新。

------

##### 2.1.3.水平分割

当路由器的一个接口收到`LSA`，存放到`LSDB`后，再从其他接口重新泛洪出去。而泛洪也存在**水平分割**的行为。

但是，`DR`会把从一个`DRother`收到的`LSA`通过原接口重新通告给其他`DRother`路由器。

通告出去的`LSA`与收到的`LSA`，唯一不同的地方是`Age`增加`1`。

------

##### 2.1.4.LSDB

`LSDB`中每份`LSA`都有唯一的身份`ID`，由三个参数构成：

- `LSA`类型
- 链路状态`ID`（`Link State ID`）

- 通告路由器的`Router-ID`

同一区域内，`LSA类型 + Link State ID + 通告路由器（Advertising Router）` 三者共同唯一确定一个LSA。

**以下图为例解释：**

- **LSA头部信息**

  |      字段      |                           值/含义                            |
  | :------------: | :----------------------------------------------------------: |
  |   **Ls id**    | `2.2.2.2` → 此LSA描述的路由器ID（即邻居路由器2.2.2.2的拓扑信息） |
  |  **Adv rtr**   | `2.2.2.2` → 通告此LSA的路由器ID（与Ls id一致，表示是自身生成的LSA） |
  |   **Ls age**   |          `36` → LSA已存活36秒（最大老化时间3600秒）          |
  |  **Options**   |               `E` → 支持外部路由（Type-5 LSA）               |
  | **Link count** |                   `2` → 该路由器有2条链路                    |

- **链路详情**

  - `TransNet`类型

    - |     字段      |                          值/含义                          |
      | :-----------: | :-------------------------------------------------------: |
      |  **Link ID**  |       `12.1.1.2` → 邻居接口IP（对端路由器接口地址）       |
      |   **Data**    | `12.1.1.2` → 本地接口IP（当前路由器连接该网络的接口地址） |
      | **Link Type** |      `TransNet` → 多路访问网络（如以太网），由DR管理      |
      |  **Metric**   |           `1` → 到达此链路的开销值（OSPF Cost）           |

  - `StubNet`类型

    - |     字段      |                   值/含义                    |
      | :-----------: | :------------------------------------------: |
      |  **Link ID**  |       `100.100.100.100` → 直连网络地址       |
      |   **Data**    | `255.255.255.255` → 子网掩码（表示主机路由） |
      | **Link Type** | `StubNet` → 末节网络（如环回接口或直连网段） |
      |  **Metric**   |          `0` → 本地接口开销通常为0           |

![image-20250810232631409](https://gitee.com/chouhama/pic/raw/master/20250810232631643.png)

------

**在不同的`LSA`类型下`Link State ID`取值不同：**

|          **LSA类型**          |        **Link State ID的含义**         |         **示例**          |
| :---------------------------: | :------------------------------------: | :-----------------------: |
|    **Type-1 (Router-LSA)**    |    **生成该LSA的路由器的Router ID**    | `1.1.1.1`（路由器自身ID） |
|   **Type-2 (Network-LSA)**    |    **DR（指定路由器）的接口IP地址**    |  `192.168.1.1`（DR的IP）  |
|   **Type-3 (Summary-LSA)**    |  **目标网络的IP地址**（被汇总的路由）  |  `10.1.0.0`（子网地址）   |
| **Type-4 (ASBR-Summary-LSA)** |          **ASBR的Router ID**           |   `2.2.2.2`（ASBR的ID）   |
| **Type-5 (AS-External-LSA)**  |       **外部路由的目标网络地址**       |   `8.8.8.0`（外部网络）   |
|     **Type-7 (NSSA-LSA)**     | **外部路由的目标网络地址**（仅NSSA内） |       `172.16.1.0`        |

------

##### 2.1.5.新旧LSA判断

判断相同`ID`的“新的”`LSA`要依次比较以下内容：

- `LSA`序列号（Sequence Number）：`32`位整数，采用线性递增的序列号，初始序列号从`0x80000001`到最大值`0x7FFFFFFF`，序列号越大代表越新，`LSA`会周期（30`min`）产生新的`LSA`，每次产生的`LSA`序列号都会增加`1`。
- `LSA`报文校验和（`Checksum`）：`16`位数，负责对刚收到的`LSA`做计算，`Age`字域不在计算范围内。即使`LSA`存放在`LSDB`中，路由器也会每`5`分钟重新计算一次。
- `LSA`年龄（`LSA Age`）：`16`位无符号整数。`LSA`的最大年龄是`3600s`。`LSA`在路由器间泛洪时每经过一跳`Age`增加`1`，在`LSDB`中存放时年龄也增加`1`。若`LSA`的年龄达到`3600s`，路由器会从`LSDB`中清除该`LSA`。
  - 在拓扑稳定的情况下，每份存放在`LSDB`中的`LSD`间隔`30min`都会被周期产生的新`LSA`刷新。

------

泛洪机制把`LSA`向区域中的每条链路通告，不论`LSA`从哪条链路泛洪到当前路由器，在路由器的`LSDB`中仅保存一份最新的`LSA`。如果收到多分`ID`相同的`LSA`，则依次比较序列号、`Checksum`及`LSA Age`，来判定是否继续泛洪该`LSA`，还是终止泛洪。

- 如果收到的`LSA`本地数据库没有，则接受且泛洪。
- 如果收到的`LSA`本地有，但收到的`LSA`比自己当前已有的`LSA`要新，则更新`LSDB`并泛洪新的`LSA`。
- 如果收到的`LSA`比自己已有的旧，则不接收。
- 如果收到的`LSA`与本地的一样新，则忽略，并终止泛洪。
- 如果收到的`LSA`损坏，比如`Checksum`错误，则不接收。

------

**判断新旧的规则如下：**

1. 序列号越大代表越新
2. 若序列号相同，则`Checksum`数值越大代表越新
3. 上述都相同的情况下，比较`Age`
   - 若`Age`为`3600s`，则认为该`LSA`更新
     - 因为`3600s`的`LSA`被通告出来表示，要将该`LSA`删除。所以这里的更新可以理解为，这个`LSA`的动作有效。
   - 若`Age`差额超过`15min`，则`Age`小的`LSA`被认定更新。
   - 若`Age`差额小于`15min`，则这两条`LSA`一样新，只保留先收到的`LSA`

------

**超时机制**

`LSA`的`Age`最大值为`3600s`，超过该值，则该`LSA`会从`LSDB`中被清除。

`LSDB`中清除`LSA`的场景如下：

1. 超过`3600s`被路由器自动清除
2. `LSA`起源路由器产生`3600s`的`LSA`并向区域中泛洪，收到的路由器用其更新自己`LSDB`中的`LSA`。泛洪`MaxAge`的`LSA`，其作用相当于**毒化**路由。

------

##### 2.1.6.总结

![image-20250811001602492](https://gitee.com/chouhama/pic/raw/master/20250811001602722.png)

`X`路由器泛洪自己的`RouterLSA`，其序列号为`8000000B`，当网络稳定后，所有路由器`LSDB`都有`X`的`LSA`。某一时刻`X`路由器突然故障，修复上线后，网络会发生什么变化？

网络稳定之后，`X`突然故障并离线。`800000B`的`LSA`在其他路由器的`LSDB`中继续存活到`3600s`，此期间因同`A`和`C`设备相连的拓扑变化，会导致`A`和`C`泛洪新的`LSA`。其他路由器重新计算路由后，网络中不再有`X`的路由。

`X`上线后，由于初次启动，`X`会产生序列号为`8000001`的`LSA`，其他相邻的路由器收到序号为`8000001`的`LSA`，而`A`和`C`的`LSDB`中有`8000000B`的`LSA`，同步后，`X`会从`A`或`C`收到序列号为`800000B`的`X`曾经产生的`LSA`。但`X`没有任何产生过该`LSA`的记录，所以`X`会立即产生一份更新的`LSA`，序列号为`0x800000C`，去覆盖网络中的旧`LSA`。此后序列号就从`0x800000c`继续开始。

------

**问题：**

![image-20250811002109455](https://gitee.com/chouhama/pic/raw/master/20250811002111382.png)

假设当前拓扑如上图，`AR1`、`AR2`、`AR3`三台路由器相互建立邻接关系，且`AR1`像网络中宣告了`1.1.1.1/32`的`LSA`。

请问：如果`AR1`与`AR3`的邻接关系中断，当前网络拓扑中还会不会保留`1.1.1.1/32`的路由。

答案：

- `AR1`与`AR3`之间的网段，一定会从`LSDB`中消失。
- `AR1`宣告的`1.1.1.1/32`一定在`LSDB`中存在，且`AR3`会学到新的。

**误导：**

1. `AR3`在`AR1`的邻接关系中断后，会向网络中泛洪`3600s`的`LSA`，以删除与`AR1`相关的路由。
2. `AR2`在收到该`LSA`后，便会删除当前`LSDB`中的与`AR1`相关的`LSA`，并且泛洪给`AR1`。

**正确步骤：**

1. `AR1`在与`AR3`邻接关系中断后，会立即向`OSPF`网络中发送`LSU`泛洪当前的所有`LSA`，且该`LSA`的序列号更新！

![image-20250811002725583](https://gitee.com/chouhama/pic/raw/master/20250811002725798.png)

2. `AR2`收到更新的`LSA`后，会通告给`AR3`，所以`AR3`会从另一个地方学到最新的`1.1.1.1/32`的`LSA`，用来代替旧的。
3. `AR3`在断开`AR1`的邻接关系后，会立刻删除`LSDB`中`13.1.1.0/24`的`LSA`并向`OSPF`网络中泛洪，`Age`为`3600s`的`LSA`，但是该`LSA`只包含`13.1.1.0/24`这个网段（`AR1`与`AR3`互联网段）

![image-20250811003116040](https://gitee.com/chouhama/pic/raw/master/20250811003116246.png)

4. `AR2`收到后删除`LSDB`中的`13.1.1.0/24`并泛洪给`AR1`。

![image-20250811003133301](https://gitee.com/chouhama/pic/raw/master/20250811003133536.png)

------

#### 2.2.域内LSA

##### 2.2.1.LSA1

每台路由器会为自己所处的每个区域产生一份`Router LSA`，该`Router LSA`包含属于该区域的所有链路的链路状态信息。`Router LSA`只能在所属的区域内泛洪。

![image-20250812042319031](https://gitee.com/chouhama/pic/raw/master/20250812042319260.png)

- 其他内容前面讲过了，不再复述。
- **V（Virtual Link）：**如果产生此`LSA`的路由器是虚连接的端点，则置为1。
- **E（External）：**如果产生此`LSA`的路由器是`ASBR`，则置为1。
- **B（Border）：**如果产生此`LSA`的路由器是`ABR`，则置为1。
- **links：**`LSA`中的`Link`(链路)数量。`Router LSA`使用`Link`来承载路由器直连接口的信息。

------

**Link类型及描述**

`OSPF`定义了四种类型的`Link`，路由器接口的`OSPF`网络类型不同，产生的`Link`也不同，路由器把所有接口的`Link`放到`RouterLSA`中在区域内泛洪。

`Router LSA`使用`Link`来承载路由器直连接口的信息。每条`Link`都包含**链路类型、链路ID、链路数据以及度量值**。路由器可能会采用一个或者多个`Link`来描述某个端口。

![image-20250812044402354](https://gitee.com/chouhama/pic/raw/master/20250812044402557.png)

|      Type      |        描述        |      Link ID      |     Link Data     |
| :------------: | :----------------: | :---------------: | :---------------: |
| Point-to-point |   点到点类型链路   |  邻居路由器的RID  | 自己的接口IP地址  |
|  TransNetwork  |     MA类型链路     |  DR的接口IP地址   | 自己的接口IP地址  |
|  StubNetwork   | 末节类型链路(网络) |      网络号       |     网络掩码      |
|  Virtual Link  |   虚拟点到点链路   | Vlink对端ABR的RID | 本地Vlink的IP地址 |

------

**类型一·：`Point-to-Point`**

`OSPF`节点间为**点到点链路**，如`PPP`或`HDLC`链路，`OSPF`默认的网络类型为`ospf network point-to-point`，则节点在表述拓扑关系时，使用`Point-to-Point`类型`Link`。

![image-20250812044119433](https://gitee.com/chouhama/pic/raw/master/20250812044119643.png)

**类型二：`TransNet`**

![image-20250812044315097](https://gitee.com/chouhama/pic/raw/master/20250812044315306.png)

**类型三：`Stub`**

`StubNetwork`代表一个网络，用末梢节点来表示，附着在实节点上，不表示任何连接关系，其实是实节点上的网络。在`OSPF`逻辑图上`StubNet`类型`link`可以表示挂在实节点上的叶子节点。

![image-20250812044821787](https://gitee.com/chouhama/pic/raw/master/20250812044822005.png)

------

##### 2.2.2.LSA2

`Network LSA`，用来表述多路访问网络上的拓扑关系。`Network LSA`仅出现在`Broadcast`或`NBMA`的网络上。这两个网络类型会选举`DR`，选举出来的`DR`除用于数据库同步外，`DR`也负责产生`LSA2`。`LSA2`用于描述**虚节点**周边的连接关系。

`Network LSA`记录了该网段内所有与`DR`建立了邻接关系的`OSPF`路由器，同时携带了该网段的网络掩码。

![image-20250812045416736](https://gitee.com/chouhama/pic/raw/master/20250812045416958.png)

- **Link State ID：**`DR`的接口`IP`地址。
- **Network Mask：**`MA`网络的子网掩码。
- **Attached Router：**连接到该`MA`网络的路由器的`Router-ID`（所有），如果有多台路由器接入`MA`网络，则使用多个字段描述。

![image-20250812045648794](https://gitee.com/chouhama/pic/raw/master/20250812045649041.png)

------

##### 2.2.3.问题与总结

**问题一：**

在`P2P`链路中没有描述**网络号**，那在学习路由的时候，怎么知道目的网段的掩码信息？

|      Type      |        描述        |      Link ID      |     Link Data     |
| :------------: | :----------------: | :---------------: | :---------------: |
| Point-to-point |   点到点类型链路   |  邻居路由器的RID  | 自己的接口IP地址  |
|  TransNetwork  |     MA类型链路     |  DR的接口IP地址   | 自己的接口IP地址  |
|  StubNetwork   | 末节类型链路(网络) |      网络号       |     网络掩码      |
|  Virtual Link  |   虚拟点到点链路   | Vlink对端ABR的RID | 本地Vlink的IP地址 |

**回答：**

`p2p`链路仅描述连接关系，在同一个`Router LSA`中，会有一个`StubNetwork`类型的链路与之关联。如下图：

![image-20250812050807352](https://gitee.com/chouhama/pic/raw/master/20250812050807596.png)

**为什么这么设计：**

`OSPF`的`Type-1 LSA`需要同时描述拓扑和网络信息，因此拆分为两种链路类型：

- `P2P/TransNetwork/Virtual Link`：描述邻居关系（动态路由计算使用，实节点）。
- `StubNetwork`：描述直连网段（用于生成路由表）。

------

**问题二：**

为什么`TransNet`不使用`StubNetwork`的方式实现，而是使用`LSA 2`。

**回答：**

- **P2P 链路** 是**直接连接两个路由器**，没有 DR，因此需要额外用 **StubNetwork 补充掩码**。
- TransNetwork（MA 网络）的掩码信息已经隐含在 Network LSA（Type-2 LSA）中：
  - **DR 会生成 Type-2 LSA**，其中包含 **MA 网络的 IP 网段和掩码**。
  - 所有路由器通过 Type-2 LSA 就能知道该 MA 网络的掩码，**不需要像 P2P 那样额外用 StubNetwork 补充**。

------

**问题三：**

为什么`TransNetwork`中，`Link ID`是`DR`的接口地址，`Link Data`是自己的接口地址？

|      Type      |        描述        |      Link ID      |     Link Data     |
| :------------: | :----------------: | :---------------: | :---------------: |
| Point-to-point |   点到点类型链路   |  邻居路由器的RID  | 自己的接口IP地址  |
|  TransNetwork  |     MA类型链路     |  DR的接口IP地址   | 自己的接口IP地址  |
|  StubNetwork   | 末节类型链路(网络) |      网络号       |     网络掩码      |
|  Virtual Link  |   虚拟点到点链路   | Vlink对端ABR的RID | 本地Vlink的IP地址 |

**回答：**

自己的接口地址，这个很好理解是为了计算到`Link ID`（邻居）的开销的。那为啥`TransNetwork`的`Link ID`填的都是`DR`的接口IP地址呢？

因为，你在`MA`网络中有`DR`的存在，且你所有通过`MA`网络学习到的`LSA`都是通过`DR`，那理所当然的你应该计算到`DR`的开销。

![image-20250812051525495](https://gitee.com/chouhama/pic/raw/master/20250812051525734.png)

------

##### 2.2.4.SPF算法

`SPF`算法计算时包含三步：

**第一步：**路由器根据`LSDB`中的`LSA`画出网络图（`Graph`），在这个`Graph`上包含`OSPF`网络拓扑中所有"点"和“比边”，画图需要使用`LSA 1`中`p2p`、`TransNet`和`Vlink`类型及`LSA 2`来描述拓扑。**也就是说先画出包括当前节点在内的拓扑图。**

![image-20250812064145530](https://gitee.com/chouhama/pic/raw/master/20250812064145749.png)

**注意：**每台路由器的`LSDB`内容一样，所以在每台路由器根据`LSDB`画出的区域内的`Graph`也是一样的。区别是根路由器不一样，每台路由器是以自己为起点开始画`Graph`的。

------

**第二步：**路由器以自己为树根，对`Graph`执行`SPF`计算。画出一颗由树根到图中每个节点的最短成本路径树，从树根到树根上任何其他节点的成本是最小的。**也就说，需要计算出到每一个节点最优选的路径。**

![image-20250812064327250](https://gitee.com/chouhama/pic/raw/master/20250812064327467.png)

**问题：**`R1`在这个物理拓扑张到达`R2`有几条路径？==切记，你有眼睛，但是`OSPF`没有眼睛，需要依赖算法。==

------

**第三步：**在树的节点上添加网络信息，并计算由树根到这些网络的成本及下一跳，并把计算结果加入到路由表中。把`SPF`树上添加的网络，称为叶子节点。`SPF`已计算出树根到任何节点的最小距离，再把代表网络的叶子节点挂在`SPF`树的相应网络节点上。树根到网络的路由成本等于树根到网络节点的距离加网络节点到叶子节点的成本。叶子节点可以是`LSA 1`中的`StubNet`、`LSA2`中的网络、`LSA3`的网络、`LSA5/7`的网络。

![image-20250812064619088](https://gitee.com/chouhama/pic/raw/master/20250812064619372.png)

**注意：**`Stub`网络挂在路由器节点（实节点）上，`LSA2`挂在虚节点上（`DR`）上，`LSA3`的网络挂在`ABR`节点上，`LSA7挂在`ASBR`节点上，而`LSA5`则可能挂再`ASBR`或`ABR`上，这要依据`ASBR`路由器是否在当前区域内而定。

------

##### 2.2.5.iSPF（Incremental SPF）==看看得了==

- **iSPF（增量最短路径优先）** 是 OSPF 的一种优化算法，用于 **减少 SPF（最短路径优先）计算的开销**。
- 传统 SPF 在拓扑变化时会 **重新计算整个最短路径树（SPT）**，而 iSPF **只计算受影响的部分**，提高收敛速度。

**作用：**

- **减少 CPU 负载**：避免每次变化都进行全量计算。
- **加快收敛**：仅更新受影响的路由，提高网络恢复速度。
- **适用于大型网络**：在核心路由器上特别有用，避免频繁全量 SPF 计算。

**工作原理：**

1. **初始 SPF 计算：**
   - 路由器首次启动或拓扑稳定时，运行 **完整 SPF**，构建 SPT（最短路径树）。
2. **拓扑变化时：**
   - 如果某条链路状态（LSA）发生变化（如链路 up/down），OSPF 会 **仅重新计算受影响的节点和路径**，而不是整个网络。
   - 例如：
     - 如果 **某个叶子节点（末梢网络）** 发生变化，iSPF 只更新该节点到根（自己）的路径。
     - 如果 **关键节点（如 ABR/ASBR）** 变化，可能会触发更大范围的 SPF 计算。

华为采用初次计算过程执行`Full SPF`，而此后不论发生什么变化，只把故障节点及其周边的连接关系重画，执行`iSPF`计算，只计算变化的部分，而不是全部计算。

------

##### 2.2.6.PRC（Partial Route Calculation）==看看得了==

- **PRC（部分路由计算）** 是 OSPF 的另一种优化机制，用于 **减少路由表计算的开销**。
- 它 **不涉及 SPF 计算**，而是 **仅更新受影响的 IP 路由**（如外部路由或末梢网络变化）。

**作用：**

- **极低计算开销**：不涉及 SPF 计算，仅更新路由表。
- **适用于外部路由变化**：如 BGP 重分发进 OSPF 时，PRC 可以快速更新路由。
- **与 iSPF 互补**：PRC 处理路由变化，iSPF 处理拓扑变化。

**工作原理：**

1. **初始 SPF 计算：**
   - 路由器运行 SPF 计算，构建拓扑（SPT），并生成路由表。
2. **拓扑变化时：**
   - 如果 **仅影响 IP 路由（如外部路由或 Stub 网络变化）**，OSPF 会 **跳过 SPF 计算**，直接更新路由表。
   - 例如：
     - 如果 **某个外部路由（Type-5/7 LSA）** 变化，PRC 直接更新该路由，而不重新计算 SPT。
     - 如果 **某个 Stub 网络（Type-1 LSA 中的 StubNetwork）** 变化，PRC 仅更新该网段的路由。

**说人话：**

当网络中的叶子节点发生变化（外部网络引入、增加末节网络等），此时不需要重新计算`SPT`。

因为从根节点到树中的任何实或虚节点的最短路径已经确定了，那么到叶子节点的最短路径也就确定了。那么到节点发布的路由的最短路径也就确定了。

所以，`PRC`就是在`SPF`计算出的最短路径树的基础上再计算叶子节点的路由。当路由信息改变，`PRC`直接判断在哪条链路上的节点的哪个叶子出现变化，之后直接进行路由的计算与更新。

------

##### 2.2.7.实验验证理论

请用如下拓扑图，介绍清楚当前整个`OSPF`网络中，有哪些是`p2p link`、`transnet link`、`stub link`和`LSA 2`以及`SPT`怎么计算。

![image-20250812073015761](https://gitee.com/chouhama/pic/raw/master/20250812073016005.png)



------

#### 2.3.域间LSA

为了避免单区域产生的`LSDB`庞大及链路更新造成的链路拥塞问题，需要在设计拓扑时使用多区域划分的方式。随之而来的就是区域与区域之间传递`LSA`。

`Router LSA`和`Network LSA`只在区域内泛洪，因此通过区域划分在一定程度上降低网络设备的内存及CPU的消耗。

![image-20250812082615606](https://gitee.com/chouhama/pic/raw/master/20250812082615865.png)

##### 2.3.1.LSA3

`OSPF`区域间路由信息传递是通过`ABR`产生的`Network Summary LSA`（3类LSA）实现的。

![image-20250812082801908](https://gitee.com/chouhama/pic/raw/master/20250812082802149.png)

理论上，因为所有的非骨干区域都必须且只能与骨干区域相连，所以本质上`ABR`必然有一个或多个接口处在`Area 0`。

**LSA3的产生与传播过程：**

![image-20250812160421317](https://gitee.com/chouhama/pic/raw/master/20250812160421546.png)

第一步：在`Area 0`和`Area 1`中，区域内的网络通过`LSA 1`和`LSA 2`在区域内泛洪。

此时在`Area 0`中会有如下`LSA`信息：

- `LSA1`：
  - `AR2`通告的`12.1.1.2`
  - `AR1`通告的`12.1.1.1`
  - `AR1`通告的`StubNet 1.1.1.1/32`
- `LSA2`：
  - `DR`通告的`12.1.1.0/24`

此时在`Area 1`中会有如下`LSA`信息：

- `LSA1`：
  - `AR2`通告的`23.1.1.2`
  - `AR3`通告的`23.1.1.3`
  - `AR3`通告的`StubNet 3.3.3.3/32`
- `LSA2`：
  - `DR`通告的`23.1.1.0/24`

------

第二步：`ABR(AR2)`负责将从这两个区域中学习到的`LSA`，稍作修改生成`LSA3`并向对应区域进行通告。

![image-20250812161919045](https://gitee.com/chouhama/pic/raw/master/20250812161919301.png)

------

**LSA3特性**

1. 边界路由器`ABR`为区域内的每条`OSPF`路由各产生一份`LSA3`并向其他区域通告。
2. 边界若有多个`ABR`，则每个`ABR`都产生`LSA3`来通告区域间路由。通过`Adveristing Router`字域来区分。
3. 区域间传递的是路由，`LSA3`是由每个区域的`ABR`产生的、并仅在该区域内泛洪的一类`LSA`。路由进入其他区域后，再由该区域的`ABR`产生`LSA3`继续泛洪。
4. `OSPF`在区域边界上具备适量特性，只有出现在`ABR`路由表里的路由才会被通告给邻居区域。
5. 计算路由时，路由器计算自己区域内到`ABR`的成本加上`LSA3`传递的区域间成本，得到的是当前路由器到目标网段端到端的成本。
6. 如果`ABR`路由器上路由表中的某条`OSPF`路由不再可达，则`ABR`会立即产生一份`3600s`的`LSA3`向区域内泛洪，用于在区域内撤销该网络。

------

##### 2.3.2.区域间路由防环机制

如下图，如果`OSPF`不要求非骨干区域必须直连骨干区域的话，就会出现如下图的环路问题。

![image-20250812190937887](https://gitee.com/chouhama/pic/raw/master/20250812190938180.png)

------

`ASBR`不会将描述到达某个区域内网段路由的`LSA3`再注入回该区域。

![image-20250812191136852](https://gitee.com/chouhama/pic/raw/master/20250812191137122.png)

------

`ABR`不会将从非骨干区域学习到的`LSA3`传播到骨干区域。因为非骨干区域必须连接着骨干区域，那么就代表非骨干区域中的`LSA3`一定是从骨干区域学习到的，那么就不能再传播回骨干区域了。

![image-20250812191316104](https://gitee.com/chouhama/pic/raw/master/20250812191316360.png)

------

#### 2.4.虚连接（Vlink）

`Vlink`是用来修复骨干区域分割的一种**临时**的解决方案。如果骨干区域被分割，修复被分割的骨干区域，要在非骨干区域上创建`Vlink`来维持骨干区域的连通信。以下图为例：

- `Vlink`被看作是骨干区域的点到点的链路，其配置在两个`ABR`之间。
- `Vlink`在两个`ABR`间创建属于骨干区域的邻居关系。这个邻居关系是单播的，穿过区域1，其单播地址是根据区域1中的`R2`和`R3`的`Router LSA`计算出来的。`Router LSA`中用于描述拓扑的`Link`中，`Link Data`是路由器自身的接口`IP`，这个`IP`地址就是`Vlink`使用的单播地址。
- 承载`Vlink`的这个`Area 1`称为`Transit Area`，当`Vlink`创建好后，该区域也像骨干区域一样，`R1`访问`R4`的流量经过`Area 1`传递。`Transit Area`不能是`Stub或NSSA`区域。

![image-20250812194928256](https://gitee.com/chouhama/pic/raw/master/20250812194928496.png)

##### 2.4.1.Vlink的应用场景

1. 连接断开的`Area 0`

![image-20250812195242095](https://gitee.com/chouhama/pic/raw/master/20250812195242358.png)

2. 修复`Area 2`未连接到`Area 0`

![image-20250812195307112](https://gitee.com/chouhama/pic/raw/master/20250812195307371.png)

##### 2.4.2.**实验一：**

![image-20250812195658593](https://gitee.com/chouhama/pic/raw/master/20250812195658860.png)

基础代码忽略，`Vlink`配置如下：

```
[AR2]ospf 1
[AR2-ospf-1]area 1
[AR2-ospf-1-area-0.0.0.1]vlink-peer 3.3.3.3

[AR3]ospf 1
[AR3-ospf-1]area 1	
[AR3-ospf-1-area-0.0.0.1]vlink-peer 2.2.2.2

[AR2-ospf-1-area-0.0.0.1]dis ospf vlink 

	 OSPF Process 1 with Router ID 2.2.2.2
		 Virtual Links 

 Virtual-link Neighbor-id  -> 3.3.3.3, Neighbor-State: Full

 Interface: 23.1.1.2 (GigabitEthernet0/0/1)
 Cost: 1  State: P-2-P  Type: Virtual 
 Transit Area: 0.0.0.1 
 Timers: Hello 10 , Dead 40 , Retransmit 5 , Transmit Delay 1 
 GR State: Normal
```

**现象：**

从下图`Router LSA`可知，`Vlink`的实际作用是将`AR3`加入到当前的`Area0`，从逻辑拓扑上看，此时`Area 0`有三台设备`AR1、AR2、AR3`，那么此时的`Area 0`就有两台`ABR`了，那既然此时`AR3`是`Area0`和`Area2`的`ABR`，这两个区域之间的路由也就可以通过`AR3`传播了。

![image-20250812220627810](https://gitee.com/chouhama/pic/raw/master/20250812220628097.png)

------

##### 2.4.3.**实验二：**

![image-20250812221316159](https://gitee.com/chouhama/pic/raw/master/20250812221316412.png)

```
[AR2]ospf 1
[AR2-ospf-1]area 1
[AR2-ospf-1-area-0.0.0.1]vlink-peer 3.3.3.3

[AR3]ospf 1 router-id 3.3.3.3
[AR3-ospf-1]area 1
[AR3-ospf-1-area-0.0.0.1]vlink-peer 2.2.2.2

[AR3]dis ospf vlink 

	 OSPF Process 1 with Router ID 3.3.3.3
		 Virtual Links 

 Virtual-link Neighbor-id  -> 2.2.2.2, Neighbor-State: Full

 Interface: 23.1.1.2 (GigabitEthernet0/0/0)
 Cost: 1  State: P-2-P  Type: Virtual 
 Transit Area: 0.0.0.1 
 Timers: Hello 10 , Dead 40 , Retransmit 5 , Transmit Delay 1 
 GR State: Normal
```

观察：最终`1.1.1.1/32`是几类`LSA`被`AR4`学习到的？

------

##### 2.4.4.**实验三（作业）：**

![image-20250813151426300](https://gitee.com/chouhama/pic/raw/master/20250813151433571.png)

------

**扩展**

![image-20250813165735875](https://gitee.com/chouhama/pic/raw/master/20250813165743205.png)

------

#### 2.5.外部LSA

通常我们会遇到网络中除了`OSPF`协议之外还有其他路由协议（其他`OSPF`进程），此时，不同协议默认是不会互相传递路由信息的，那就需要额外做一个操作——**引入（重分发）**。

引入外部路由的`OSPF`设备有一个名称叫做`ASBR(AS Boundary Router)`自治系统边界路由器。**成功引入外部路由有一个前提，该路由必须存在于`ASBR`的路由表内。**

`ASBR`将外部路由信息以`LSA 5`的形式在`OSPF`网络内泛洪。

![image-20250813181034886](https://gitee.com/chouhama/pic/raw/master/20250813181035150.png)

##### 2.5.1.LSA5

由`ASBR`产生，描述到达`AS`外部的路由，该`LSA`会被通告到所有的区域（除了`Stub`区域和`NSSA`区域）。

![image-20250813181616457](https://gitee.com/chouhama/pic/raw/master/20250813181616703.png)

- `LS Type`：取值5，代表`LSA 5`。
- `Link State ID`：外部路由的目的网络地址。
- `Advertising Router`：生成该`LSA`的`Router ID`。
- `Network Mask`：网络掩码
- `E`：该外部路由所使用的度量值类型
  - `0`：度量值类型为`Metric-Type-1`
  - `1`：度量值类型为`Metric-Type-2`
- `metric`：到目的网络的路由开销。
- `Forwarding Address(FA)`：到所通告的目的地址的报文将被转发到这个地址。

------

##### 2.5.2.LSA4

`ASBR-Summary LSA`：由`ABR`产生，描述到`ASBR`的路由，通告给除`ASBR`所在区域的其他相关区域。

![image-20250813182208879](https://gitee.com/chouhama/pic/raw/master/20250813182209163.png)

- `LS Type`：取值4，代表`LSA 4`。
- `Link State ID`：`ASBR`的`Router-ID`。
- `Advertising Router`：生成`LSA`的`Router-ID`。
- `Network Mask`：仅保留，无意义。
- `metric`：到目的地址的路由开销。

------

**问题：**

为什么有了`LSA 5`还需要`LSA 4`呢？

**答案：**

`LSA 5`的`Advertising Router`明确指出是由哪一台路由器通告的该`LSA`。但是，在其他区域的`STP`树上并不存在该节点，所以，还需根据`ABR`产生的`LSA 4`进行计算。

而实际上，`LSA 4`只是告诉其他路由器，你到达`LSA 5`的下一跳应该是`ABR`。而当数据包到达`ABR`后，`ABR`可以根据`LSA 1`找到`ASBR`。

------

**实验：**

![image-20250813182755713](https://gitee.com/chouhama/pic/raw/master/20250813182755980.png)

------

##### 2.5.3.度量值类型

- `Metric-Type-1`
  - 当外部路由的开销与`AS`内部的路由开销相当，并且和`OSPF`自身路由的开销有可比性时，可以认为这类路由的可信程度较高，将其配置`Metric-Type-1`。
  - `Metric-Type-1`外部路由的开销为`AS`内部开销与`AS`外部开销之和。
- `Metric-Type-1`
  - 当`ASBR`到`AS`之外的开销远远大于在`AS`之内到达`ASBR`的开销时，可以认为这类路由的可信程度较低，将其配置成`Metric-Type-2`.
  - `Metric-Type-2`外部路由的开销等于`AS`外部开销。也就是只计算外部开销。

```
import-route <Router-Protocol> type 1
```

------

#### 2.6.特殊区域

`OSPF`路由器计算区域内、区域间、外部路由都需要依靠网络中的`LSA`，当网络规模变大时，设备的`LSDB`规模也会变大，设备的路由计算能力变得更吃力，造成设备性能浪费。

![image-20250815165100293](https://gitee.com/chouhama/pic/raw/master/20250815165107604.png)

那所需要做的就是，在保持数据通畅的情况下，减少`LSA`的数量，降低路由器的消耗。

特殊区域主要用于优化路由信息，减少区域内或区域间的`LSA`数量，从而降低路由器的计算负担和内存消耗。

在`OSPF`中特殊区域分为四种：

- `Stub Area`
- `Totally Stub Area`
- `NSSA Area`
- `Totally NSSA Area`

------

`OSPF`的区域可分为两种类型：

- 传输区域（`Transit Area`）：除了承载本区域发起的流量和访问区域的流量外，还承载了源`IP`和目的`IP`都不属于本区域的流量，即“穿越型流量”，如本例中的`Area 0`。
- 末端区域（`Stub Area`）：只承载本区域发起的流量和访问本区域的流量，如本例中的`Area 1`和`Area2`。

![image-20250815165356685](https://gitee.com/chouhama/pic/raw/master/20250815165356941.png)

------

##### 2.6.1.Stub区域

`Stub`区域的`ABR`不向`Stub`区域内传播它接收到的`AS`外部路由，`Stub`区域中路由器的`LSDB`、路由表规模都会大大减小。

为保证`Stub`区域能够到达`AS`外部，`Stub`区域的`ABR`将生成一条缺省路由（使用3类`LSA`描述）。

简单一句话总结，`Stub`区域的作用就是`ABR`生成一条`LSA3`的默认路由，代替所有`LSA 5`。

![image-20250815170606569](https://gitee.com/chouhama/pic/raw/master/20250815170606808.png)

配置`Stub`区域时需要注意以下几点：

- 骨干区域不能配置为`Stub`区域
- `Stub`区域中的所有路由器都必须将该区域配置为`Stub`
- `Stub`区域内不能引入也不能接收`AS`外部路由
- 虚连接不能穿越`Stub`区域

------

##### 2.6.2.Totally Stub区域

`Totally Stub`区域既不允许`AS`外部路由在本区域内传播，也不允许区域间路由在本区域内传播。

`Totally Stub`区域内的路由器通过本区域`ABR`下发的缺省路由（使用3类`LSA`描述）到达其他区域，以及`AS`外部。

![image-20250815170729905](https://gitee.com/chouhama/pic/raw/master/20250815170730166.png)

------

##### 2.6.3.NSSA与Totally NSSA

`OSPF`规定`Stub`区域是不能引入外部路由的，这样可以避免大量外部路由引入造成设备资源消耗。对于既需要引入外部路由又要避免外部路由带来的资源消耗的场景，就需要用`NSSA`了。

![image-20250815170857824](https://gitee.com/chouhama/pic/raw/master/20250815170858078.png)

你可以简单地理解为，`NSSA`区域就是可以引入外部路由的`Stub`区域，而`Totally NSSA`区域就是可以引入外部路由的`Stub`区域。

![image-20250816165053044](https://gitee.com/chouhama/pic/raw/master/20250816165100447.png)

**七类LSA**

由`ASBR`产生，用于描述到达`OSPF`域外的路由。`NSSA LSA`与`AS`外部`LSA`功能类似，但是泛洪范围不同。`NSSA LSA`只能在始发的`NSSA`内泛洪，并且不能直接进入`Area 0` ，`NSSA`的`ABR`会将`LSA 7`转换成`LSA5`注入到`Area 0`。

------

##### 2.6.3.实验一：Stub

![image-20250816230050874](https://gitee.com/chouhama/pic/raw/master/20250816230051163.png)

![image-20250816230329286](https://gitee.com/chouhama/pic/raw/master/20250816230329567.png)

![image-20250816230315533](https://gitee.com/chouhama/pic/raw/master/20250816230315819.png)

**结论：**

在`Area 2`中，`AR4`能够学习到`LSA3`的明细路由与`LSA3`的默认路由。

------

##### 2.6.5.实验二：Totally Stub

![image-20250816230050874](https://gitee.com/chouhama/pic/raw/master/20250816230516322.png)

![image-20250816230729842](https://gitee.com/chouhama/pic/raw/master/20250816230730149.png)

![image-20250816230742198](https://gitee.com/chouhama/pic/raw/master/20250816230742493.png)

**结论：**

在`AR4`上已经不存在明细`LSA3`了，只留下一条默认`LSA3`。

------

##### 2.6.4.实验三：NSSA

![image-20250816225136103](https://gitee.com/chouhama/pic/raw/master/20250816225136380.png)

**基础配置忽略**

![image-20250816223414635](https://gitee.com/chouhama/pic/raw/master/20250816223414952.png)

![image-20250816223426093](https://gitee.com/chouhama/pic/raw/master/20250816223426388.png)

![image-20250816223401242](https://gitee.com/chouhama/pic/raw/master/20250816223401533.png)

![image-20250816223346064](https://gitee.com/chouhama/pic/raw/master/20250816223346340.png)

![image-20250816223524348](https://gitee.com/chouhama/pic/raw/master/20250816223524640.png)

**结论：**

在`NSSA`区域内由`ABR`在区域内发送`LSA7`的默认路由，用来过滤掉外部路由。同时，`ABR`会将`LSA3`发送到`NSSA`区域中。

在`NSSA`区域内`ASBR`会将外部路由以`LSA7`的方式发送到当前区域，由当前区域的`ABR`把路由以`LSA5`的方式发送到骨干区域。

在`Area 1`中，`ABR`负责将`Area 0`中的`LSA 5`转发到`Area 1`，并且生成`LSA 4`描述去往`NSSA`区域的`ABR`的路由信息。

------

##### 2.6.5.实验四：Totally NSSA

![](https://gitee.com/chouhama/pic/raw/master/20250816225140372.png)

**基础配置忽略**

![image-20250816225438974](https://gitee.com/chouhama/pic/raw/master/20250816225439257.png)

![image-20250816225453383](https://gitee.com/chouhama/pic/raw/master/20250816225453698.png)

**结论：**

`Area 2`外的路由器与`NSSA`实验中的现象没有任何区别。

`Area 2`中的路由器的`LSDB`发生了变化，`LSA3`明细路由全部被过滤，只留下（汇总）一条`0.0.0.0`的`LSA3`。除此之外，`LSA7`的默认路由依旧存在。**为什么呢？路由表选择哪一条？**

------

#### 2.7.选路规则

1. **通过路由类型进行选路**

| **优先级** |       **路由类型**       |                        **描述**                        |
| :--------: | :----------------------: | :----------------------------------------------------: |
|   **1**    |      **Intra-Area**      |        **区域内路由**（同一 OSPF 区域内的路由）        |
|   **2**    |      **Inter-Area**      |   **区域间路由**（来自其他 OSPF 区域，由 ABR 通告）    |
|   **3**    | **Type 1 External (E1)** |  **外部路由（E1）**，计算外部路由开销 + 内部路径开销   |
|   **4**    | **Type 2 External (E2)** | **外部路由（E2）**，**仅计算外部路由开销**（默认类型） |
|   **5**    |   **NSSA Type 1 (N1)**   | **NSSA 外部路由（N1）**，类似 E1，计算外部 + 内部开销  |
|   **6**    |   **NSSA Type 2 (N2)**   |    **NSSA 外部路由（N2）**，类似 E2，仅计算外部开销    |

2. **如果存在多条相同类型的路由，`OSPF`会通过`Cost`进行选路**
3. **如果`Cost`也相同，则负载均衡**

**修改：**

如果，路由类型与`Cost`都相同，且有多个`ABR`将外部路由传递到当前路由器，优先选择`Area`大的。如果`Area`也一致，则负载均衡。

------

#### 2.8.报文认证

`OSPF`支持两种`OSPF`报文认证方式，当两种认证方式都存在时，优先使用接口认证方式：

- **区域认证方式：**一个`OSPF`区域中所有的路由器在该区域下的认证模式和口令必须一致。
- **接口认证方式：**相邻路由器直连接口下的认证模式和口令必须一致。

------

如下，在`OSPF`中认证模式分为以下几类：

- `hmac-md5`：支持`Key-ID` + 密码认证，防篡改，防重放攻击。
- `md5`：兼容旧设备，安全性不如`hmac-md5`
- `simple`：明文认证，明文传输密码。
- `keychain`：动态密钥连，适用于安全性极高的网络。
- `null`：不启用认证。

```
[AR4-ospf-1-area-0.0.0.1] authentication-mode ?
  hmac-md5  Use HMAC-MD5 algorithm  # HMAC-MD5 认证（推荐）
  keychain  Keychain authentication mode  # 动态密钥链认证（高级）
  md5       Use MD5 algorithm  # 传统 MD5 认证（兼容旧设备）
  simple    Simple authentication mode  # 明文认证（不安全）
  
[AR4-GigabitEthernet0/0/0] ospf authentication-mode ?
  hmac-md5  Use HMAC-MD5 algorithm
  keychain  Keychain authentication mode
  md5       Use MD5 algorithm
  null      Use null authentication  # 关闭认证（默认）
  simple    Simple authentication mode
```

------

##### 2.8.1.实验一：接口认证明文

![image-20250816232340228](https://gitee.com/chouhama/pic/raw/master/20250816232340532.png)

```
interface GigabitEthernet0/0/0
 ip address 12.1.1.1 255.255.255.252 
 ospf authentication-mode simple cipher %$%$LVwQ@Rj`3M'3s{Vx2d2~yUnj%$%$ 
 
interface GigabitEthernet0/0/0
 ip address 12.1.1.2 255.255.255.252 
 ospf authentication-mode simple cipher %$%$lTQLAl$R'BB6*W~}cPm3yUO~%$%$ 
```

![image-20250816232828951](https://gitee.com/chouhama/pic/raw/master/20250816232829230.png)

**字段解释：**

```
  STRING<1-8>/<32>  The password (key)
  cipher            Encryption type (Cryptogram)
  plain             Encryption type (Plain text)
```

- `STRING <1-8>`：表示密码长度为`1-8`个字符
- `STRING <32>`：标识密码长度扩展至`32`个字符
- `cipher`：密码会以**加密**形式（哈希值）存储在配置文件中
- `plain`：密码以**明文形式**存储，可直接查看

------

##### 2.8.2.实验二：区域认证密文

![image-20250816233316041](https://gitee.com/chouhama/pic/raw/master/20250816233316334.png)

```
 area 0.0.0.0 
  authentication-mode md5 1 cipher %$%$38(L=WWT6("5/'Ai%4y'y^ML%$%$
```

![image-20250816233757925](https://gitee.com/chouhama/pic/raw/master/20250816233758218.png)

------

#### 2.9.路由汇总

路由汇总又被称为路由聚合，即将一组前缀相同的路由汇聚成一条路由，从而达到减小路由表规模以及优化设备资源利用率的目的。我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚之后的这条路有称为汇总路由或聚合路由。

**OSPF路由汇总的类型：**

- 在`ABR`执行路由汇总：对区域间的路由执行路由汇总。
- 在`ASBR`执行路由汇总：对引入的外部路由执行路由汇总。

------

**示例：**

假设现在有如下子网需要进行汇总，最精确的网段是什么？

- `192.168.0.0/24`
- `192.168.1.0/24`
- `192.168.2.0/24`
- `192.168.3.0/24`

```
192.168.0.0:   11000000.10101000.00000000.00000000
192.168.1.0:   11000000.10101000.00000001.00000000
192.168.2.0:   11000000.10101000.00000010.00000000
192.168.3.0:   11000000.10101000.00000011.00000000
```

所以，汇总后的网段为：`192.168.0.0/22`

------

##### 2.9.1.实验一：区域间汇总

![image-20250817130705940](https://gitee.com/chouhama/pic/raw/master/20250817130713255.png)

在`ABR`还没有做汇总时，`AR3`上能够学习到`LSA 3`明细路由。

![image-20250817131129654](https://gitee.com/chouhama/pic/raw/master/20250817131129952.png)

**区域间汇总配置：**

```
ospf 1 router-id 2.2.2.2 
 area 0.0.0.0 
  abr-summary 192.168.0.0 255.255.0.0
  network 12.1.1.2 0.0.0.0 
 area 0.0.0.1 
  network 23.1.1.1 0.0.0.0
```

![image-20250817131250016](https://gitee.com/chouhama/pic/raw/master/20250817131250306.png)

------

##### 2.9.2.实验二：区域外汇总

![image-20250817131522742](https://gitee.com/chouhama/pic/raw/master/20250817131523045.png)

```
ospf 1 router-id 3.3.3.3 
 asbr-summary 172.16.0.0 255.255.0.0
 import-route direct
 area 0.0.0.1 
  network 23.1.1.2 0.0.0.0
```

![image-20250817131517069](https://gitee.com/chouhama/pic/raw/master/20250817131517425.png)

------

#### 2.10.Silent-Interface

`Silent-Interface`有以下特性：

- 不会接收和发送`OSPF`报文
- `Silent-Interface`的直连路由仍可以发布出去

**场景介绍：**

此时，`LSW1`和`LSW2`通过`G0/0/1`接口传递`Vlan 10 20`并做了`VRRP`。并且，`AR1、LSW1、LSW2`之间建立了`OSPF`邻居关系，`LSW、LSW2`会通过`OSPF`将`Vlan 10 20`宣告给`AR1`。如果此时，不做任何干预的话，会导致`LSW1`和`LSW2`通过`Vlan 10 20`建立`OSPF`邻接关系，造成额外的开销。

![image-20250817133027237](https://gitee.com/chouhama/pic/raw/master/20250817133027538.png)

------

#### 2.11.填坑

![{5c131c4e-76c9-4ad0-bcab-a1ebe43d1cbf}](https://gitee.com/chouhama/pic/raw/master/20250820163215068.png)

上节课用这个拓扑讲了外部路由以及路由选举，我们发现当`AR1`有多个`ABR`且不是一个区域时，即使路由等级相同、`Cost`值相同依旧不会出现负载均衡。但是，当`AR1`与相同区域的多个`ABR`建立了邻居之后，外部路由在`AR1`上就会是负载均衡的。

我们上结课的结论是，等级与`Cost`相等时，且`Area`不同，选择`Area`大的。

我觉得也不太严谨，是不是有可能选择`Router-ID`大的呢？

##### 2.11.1.实验说明

1. `AR1、AR2、AR3、AR4`属于`Area0`，`AR1`与`AR5`属于`Area3`，`AR3`与`AR5`属于`Area2`，`Ar4`与`AR5`属于`Area1`
2. `AR2`将`Loo0`引入到`OSPF`区域内（`Type2`），在`AR5`上观察会从哪个`ABR`上学习到。

![image-20250820161003388](https://gitee.com/chouhama/pic/raw/master/20250820161003704.png)

**结果：**

![image-20250820161755961](https://gitee.com/chouhama/pic/raw/master/20250820161756256.png)

**关闭`G0/0/0`接口：**

![image-20250820161931438](https://gitee.com/chouhama/pic/raw/master/20250820161934226.png)

**关闭`G0/0/1`接口：**

![image-20250820161955040](https://gitee.com/chouhama/pic/raw/master/20250820161955348.png)

**修改`R1`的`Router-ID`为`6.6.6.6`**

![image-20250820162429722](https://gitee.com/chouhama/pic/raw/master/20250820162430031.png)

**最终结论：**

在这种情况下，就是选择区域号最大的！

------

